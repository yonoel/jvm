# 垃圾收集与内存分配

## 概述

当需要排查内存溢出，内存泄漏，当垃圾收集系统成为系统达到更高并发量的瓶颈时，需要手控这些技术。
线程独有的内存区域不用考虑，编译期间已经决定，并且随着线程生命结束自动结束了。而重点在堆内存和方法区的内存回收。

## 对象死亡

### 引用记数法

引用了就加1，不引用-1，为0消除，其实不怎么用，很难解决对象直接循环引用的问题。

### 可达性分析法

有一个根节点GC Root,当对于GC Root不可达时则成为回收对象。

GC ROOT的回收对象有：
+   虚拟机栈（栈贞中的本地变量表）中引用的对象
+   方法区中类静态属性引用的对象
+   方法区中常量引用对象
+   本地方法栈中JNI引用对象

### 在谈引用

JDK1.2之前，引用的定义：如果Reference类型的数据中存储的数值代表的是另外一个内存的地址，则称这块Reference代表着一个引用。

过于狭隘，无法定义一些中间对象（不打算回收，暂时留着，过活回收）。因此有了强引用（Strong），软引用（Soft），弱引用（Weak），虚引用（Phantom），
引用强度依次递减。

+   强引用：在代码中普遍存在的，类似 A a = new  A() 的引用
+   软引用：描述一些还有用但非必须的对象。对于此类对象，在发生内存溢出之前，将会列入回收范围进行二次回收，如果这次回收后还没足够内存，抛溢出。即SoftReference类
+   弱引用，也是描述一些还有用但非必须的对象，比软更弱，弱引用对象只能生存到下一次GC发生之前，当GC工作时，比对回收此类对象，即WeakReference类
+   虚引用：最弱的引用，一个对象是否有此引用存在，完全不对其生寸时间有影响，也无法通过此引用获得对象实例，设置此引用的目的就是在GC时收到一个通知。即PhantomReference类

### 生存还是死亡

即使是不可达的对象，也不是非死不可的。宣告死亡，需要两步，1.发现不可达，2.开始筛选，筛选条件是此对象是否有必要执行finalize方法。当对象没有覆盖
finalize方法或者此方法已经被调用，那么没有必要回收。

若宣告死亡，将此对象放置在F-Queue队列中，有一个Finalizer线程会去执行它。若执行此方法时，对象再次被引用，则被救活了。。。注意此方法，只会被系统自动调用
一次，第二次回收，不在执行。

### 回收方法区

回收主要两部分：
+   废弃常量
+   无用的类

## 垃圾收集算法

### 标记清除算法

### 复制算法

大部分是这样的，简单粗暴高效，尤其是新生代

### 标记-整理

把可用的移动到一端，另一段全部删除，老年代

### 分代收集算法

## Hot-Spot的算法实现

### 枚举根节点

逐个检查效率低，浪费时间。其次要确保一致性。

目前是准确式G，目前用OopMap来存储这样的数据结构

### 安全点

程序并非在所有的地方都能GC,而是在达到安全点时才可以GC。
线程中断的方式：
1.  抢先式中断，让线程中断，还没到安全点的，继续跑到中断点。几乎没有这样做的了。
2.  主动式中断，设置一个标志，各个线程执行时轮询这个标志，为真时挂起线程。

### 安全区域

当一些线程Sleep或者Blocked怎么办？这里就用到了安全区域：在一段代码中，引用关系不会发生变化。

## 垃圾收集器

7种收集器

### 阅读GC日志

### 垃圾收集器的参数总结

## 内存分配与策略

### 对象优先Eden

见TestAllocation,执行了一个Eden的GC去了老年代

### 大对象直接进入老年代

大对象是指需要大量连续内存空间的Java对象，比如很长的字符串和数组。最坏的消息就是遇到一堆朝生夕灭的大对象，因为需要gc准备连续的空间。

### 长期存活的大对象直接进老年代

在Eden出生，并且能躲过eden的回收的对象，年龄+1。年龄阈值可以设置。

### 动态对象的年龄判定

达不到年龄的阈值也可以，如果在Survivor中相同年龄所有对象的大小的总和大于Survivor的一半，年龄大于这个一半的值的对象就能进入老年代。

### 空间分配担保

在Minor GC 前会检查老年代空间是否足够Eden里的搬进来。。

## 总结

没有固定收集器，参数组合，没有最优的调优法。
Eden+2个Survivor+Old = 堆 一般是mirror gc 实在不行了，FullGC -Xmx分配的内存最大值 -Xms内存最小值 -Xmn 新生代大小（官方推荐3/8） -Xss 线程所占大小

-Xmx 和 -Xms要相等,原因：
1.  如果二者不等，最开始的时候堆大小是Xms，随着heap内存消耗，jvm很有可能需要申请更大的空间直到Xmx；
相似的，jvm在申请到Xmx空间时可能又用不了，这时会缩小jvm空间，这样，虽然可以动态调整jvm堆申请的大小，
但是每一次调整都需要一定的系统开销（jvm与os之间）。
但是，注意前提——生产环境，生产环境意味着一台机器或者一个容器只有一个服务，独占机器意味着没有必要调整jvm大小，直接分配Xmx就行了。
否则每一次调整都可能会有开销。只有在开发环境，比如个人电脑，运行的进程特别多，jvm内存动态调整才可能有必要。

2.  另外，在产环境的这一前提下，如果最开始堆大小是Xms，也意味着可能会有比较多的gc，影响性能。

